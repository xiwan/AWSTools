syntax = "proto3";
package Core.Engine.Network;

enum BattleProtoIds {
  Invalid_Notify = 0;
  PingPong_Req = 1; // tcp心跳
  PingPong_Rsp = 2;


  Connect_Req = 4; // 客户端向服务器建立"连接"
  Connect_Rsp = 5;

  PlayerJoin_Req = 6;
  PlayerJoin_Rsp = 7;

  GameTime_Notify = 8;

  SelectLord_Req = 9;
  SelectLord_Rsp = 10;

  GameState_Notify = 11;

  Entity_Notify = 12;
  Resource_Notify = 13;

  Bag_Req = 14;
  Bag_Rsp = 15;

  Hp_Notify = 16;
  Team_Notify = 17;
  ModifyBattleUnit_Req = 18;
  ModifyBattleUnit_Rsp = 19;

  Damage_Req = 20;
  Damage_Rsp = 21;  //暂时空缺

  GameOver_Notify = 22;
  PendingItem_Req = 23;
  PendingItem_Rsp = 24;

  BattlePlayerCommand_Req = 25;
  BattlePlayerCommand_Rsp = 26;  //暂时空缺

  ManageCastle_Req = 27;
  ManageCastle_Rsp = 28;  //暂时空缺

  Castle_Notify = 29;
  CastleOwner_Notify = 30;
  Lord_Notify = 31;
  Physics_Notify = 32;

  Squad_Notify = 33;
  SquadOwner_Notify = 34;
  Pawn_Notify = 35;
  PawnsOwner_Notify = 36;

  EditSquad_Req = 37;
  EditSquad_Rsp = 38;  //缺失

  OrderSquad_Req = 39;
  OrderSquad_Rsp = 40;  //缺失

  Ap_Notify = 41;
  Dp_Notify = 42;
  Path_Notify = 43;
  Buff_Notify = 44;

  KcpConnect_Req = 45;
  KcpConnect_Rsp = 46;

  ScoutResult_Notify = 47;

  SkillResult_Notify = 48;
  SkillSync_Req = 49;
  SkillSync_Rsp = 50;

  PlayerAttributeChange_Req = 51;
  PlayerAttributeChange_Rsp = 52;

  TeamHomeChange_Notify = 53;

  ShowMessage_Notify = 59;

  Defeat_Notify = 61;

  Disconnect_Req = 62;
  Disconnect_Rsp = 63;

  MoveCrystal_Req = 64;
  MoveCrystal_Rsp = 65;

  EnterGame_Notify = 67;

  BattleMapControl_Req = 68;
  BattleMapControl_Rsp = 69;

  BattleUnit_Notify = 70;

  BattleMap_Notify = 71;
  BattleUnitState_Notify = 72;
  BattleMapTimer_Notify = 73;
  BattleMapPlayer_Notify = 74;
  BattleUnitAttribute_Notify = 75;
  Player_Notify = 76;

  BattleMapSetPlayerInfo_Req = 78;
  BattleMapSetPlayerInfo_Rsp = 79;  //缺失 gm？

  Ambush_Notify = 80;

  NormalChat_Req = 81;
  NormalChat_Rsp = 82;

  ParamChat_Req = 83;
  ParamChat_Rsp = 84;

  PlayerCommand_Notify = 85;
  JoinBattle_Notify = 86;
  Territory_Notify = 90;
  GridProp_Notify = 91;
  GmCommand_Req = 92;
  VisionInfo_Notify = 93;
  TeamShareEffectEntity_Notify = 94;
  PlayerRevive_Notify = 95;
  SelectLord_Notify = 96;
  CrystalRing_Notify = 97;
  BattleMapFleeFinish_Notify = 98;
  BattleBuff_Notify = 99;
  TeamTech_Notify = 100;

  EnemyPlayerPawnInfo_Notify = 102;
  BattleMapResult_Notify = 103;
  BattleMapEvent_Notify = 104;
  KillBoss_Notify = 105;
  TeleportInfo_Notify = 106;
  ReconnectInfo_Notify = 107;
  ResetGridSelect_Notify = 108;
  BattleDmg_Notify = 109;
  AttackCastle_Notify = 110;
  MoveCrystal_Notify = 111;
  Disconnect_Notify = 112;
  Bag_Notify = 113;
  PlayerAttributeChange_Notify = 114;
  SkillSync_Notify = 115;
  PendingItem_Notify = 116;
  PlayerJoin_Notify = 117;
  ChooseLord_Notify = 118;
  NormalChat_Notify = 119;
  ParamChat_Notify = 120;
  GmCommand_Rsp = 121;
  Surrender_Req = 122;
  Surrender_Rsp = 123;
  Surrender_Notify = 124;
  SurrenderSuccess_Notify = 125;
  PlayerSurrender_Notify = 126;
  BattleInstantSkill_Notify = 127;
  KDA_Notify = 128;
  Reward_Notify = 129;
  BattleUnitMove_Notify = 130;
  AddBattleUnits_Req = 131;
  SimulateBattleMap_Req = 132;
  CastleWinnerScore_Notify = 133;
  TeamWinnerScore_Notify = 134;
  MoveCrystalAnim_Notify = 135;
  HexTechChoice_Req = 136;
  HexTechChoice_Rsp = 137;
  HexTechChoiceSelect_Req = 138;
  HexTechChoiceSelect_Rsp = 139;
  BattleMapFledInfo_Notify = 140;
  Field_Notify = 141;
  SelectLordCoreCard_Req = 142;
  SelectLordCoreCard_Rsp = 143;
  BattleHistoryInfo_Notify = 144;
  SelectPlayerSkill_Req = 145;
  SelectPlayerSkill_Rsp = 146;
  BattleCreationAdd_Notify = 147;
  SelectPlayerFormation_Req = 148;
  SelectPlayerFormation_Rsp = 149;
  Loading_Notify = 150;
  Anim_Notify = 151;
  SkillRemove_Notify = 152;
  SelectLordFormation_Req = 153;
  SelectLordFormation_Rsp = 154;
  FlyCannonUse_Req = 155;
  FlyCannonUse_Rsp = 156;
  GunCarrierShellCastle_Notify = 157;
  FlyCannonUseFinish_Notify = 158;
  PlayerVisState_Req = 159;
  PlayerVisState_Rsp = 160;
  PlayerVisState_Notify = 161;
  BattleSkill_Notify = 162;
  SpawnerSync_Notify = 163;
  PlayerMoveAttack_Req = 164;
  PlayerMoveAttack_Rsp = 165;
  CardLevelUp_Notify = 166;
  TutorialCommand_Req = 167;
  SkillPrepare_Req = 168;
  SkillPrepare_Rsp = 169;
  SkillPrepare_Notify = 170;
  Reconnect_Req = 171;
  Reconnect_Rsp = 172;
  TryFindPathFromTo_Req = 173;
  TryFindPathFromTo_Rsp = 174;

  Test_Req = 9998;
  Test_Rsp = 9999;
} //


message MsgTryFindPathFromToReq{
  int32 fromGridIdx = 1;
  int32 toGridIdx = 2;
  int32 maxStep = 3;
}

message MsgTryFindPathFromToRsp{
  repeated int32 path = 1;
}



// WinnerScore_Notify = 101; // 老版战略分协议, 策划说先注释
message MsgReconnectReq{
  string info = 1;
}

message MsgGmCommandRsp{
  string info = 1;
}

message MsgMoveCrystalNotify{
  MoveCrystalInfo info = 1;
}

message MoveCrystalInfo{
  int32 newPosition = 1;
  repeated uint64 agreeList = 2;
  repeated uint64 rejectList = 3;
  int64 startTick = 4;
}

message MsgDisconnectRsp{
}

message MsgMoveCrystalAnimNotify{
  uint64 oldCrystalId = 1;
  uint64 newCrystalId = 2;
}

// 攻城成功后获胜积分变更通知
// 城池身上有一个“累积分”，这个“累积分”会随着时间流逝增加。当这座城被攻占后，占领方将会掠夺掉这些“累积分”的一部分计入自己队伍的分数中
message MsgCastleWinnerScoreNotify{
  // 胜利方积分变更信息
  repeated CommonWinnerScoreItem datas = 1;
}

message CommonWinnerScoreItem{
  // 实体id
  uint64 entityId = 1;
  // 分数
  int32 score = 2;
}

// 队伍胜利积分变更通知
message MsgTeamWinnerScoreNotify{
  // 队伍积分变更数据
  repeated CommonWinnerScoreItem datas = 1;
}

message MsgKDANotify{
  repeated KDAValue kda = 1;
}

enum KDA{
  // 击杀
  K = 0;
  // 死亡
  D = 1;
  // 助攻
  A = 2;
  // 攻城
  C = 3;
}

message KDAValue{
  // KDA数据类型
  KDA key = 1;
  // 对应的值
  int32 val = 2;
  // 数据所属的领主EntityId
  uint64 entityId = 3;
}

message MsgResetGridSelectNotify{
  PathInfo pathInfo = 1;
}

// 移动/攻击 请求
// 移动与攻击，大体上都是传递一个路径与目标点给后端，从而开启后续逻辑。但是对应两种不同的模式，参数的配置逻辑略有不同
// 
// 假设初始路径p为: [a, 1, 2, 3, b], 是一条棋盘格上的有效路径，此时玩家在a点上。
// - 
// - 当我们希望玩家移动到b点时，我们传递的path为: [a, 1, 2, 3, b, -1], 即p.Add(-1)
// - toGridIdx为: b，即p[^1]
// - 
// - 当我们希望玩家攻击b点上的敌方单位时（此时b点上必须要有敌方单位），我们传递的path为：[a, 1, 2, 3, b]，即p本身
// - toGridIdx为：3，即p[^2]
// - 
// 相当于，最终传到服务器的路径，将会把路径的最后一位视为攻击格，倒数第二位视为真正的移动终点格。
message MsgPlayerMoveAttackReq{
  // 路径下标列表
  repeated int32 path = 1;
  // 目标点下标
  int32 toGridIdx = 2;			
}

message MsgPlayerMoveAttackRsp{
  
}

// 天赋信息
message TeamTechInfo{
  // 天赋的持有者实体id
  uint64 entityId = 1;
  // 领主等级
  int32 lordLevel = 2;
  // 当前已经学习的天赋等级列表（学习天赋后，其对应的等级将被存入此列表用作标记）
  repeated int32 hexTech = 3;
  // 当前尚未学习的天赋等级列表（领主拥有指定等级的天赋点后可以选择先不学习，这样的话这个等级的天赋就会被记录在此列表中。后续如果学习了，将会被移出此列表）
  repeated int32 pendingLevel = 4;
  // 暂时无用
  int64 autoPickTick = 5;
  // 是否为 天赋:“禁止撤退”
  bool banFlee = 6;
  // 暂时无用
  int64 startPickTick = 7;
}

// 玩家天赋变更通知（领主等级提升时会获得一点天赋点，可以用于学习天赋能力）
message MsgTeamTechNotify{
  // 天赋信息
  TeamTechInfo teamTechInfo = 1;
}

message MsgFlyCannonUseReq{
  uint64 entityId = 2;
  uint64 flyCannon = 3;
  int32 gridIdx = 4;
}

message MsgFlyCannonUseRsp{
}

message MsgFlyCannonUseFinishNotify{
  uint64 entityId = 1;
  uint64 cannonCastleId = 2;
}

// 请求选择某个等级的天赋（当前领主的待选天赋等级列表不为空时即可发起此请求。待选天赋等级列表对应TeamTechInfo.pendingLevel）
// 发起这个请求后，如果对应的等级下确实存在尚未学习的天赋点，则会返回MsgHexTechChoiceRsp。
// 相当于这个请求只是申请一个可选的天赋列表，待天赋列表确定了之后，还需要再发一个具体的天赋选择请求：MsgHexTechChoiceSelectReq才能完成一个天赋的获取。
message MsgHexTechChoiceReq{
  // 玩家控制的领主实体id
  uint64 entityId = 2;
  // 要选择天赋的等级（TeamTechInfo.pendingLevel列表中存的就是尚未学习天赋的等级）
  int32 level = 3;
}

// MsgHexTechChoiceReq的回包
message MsgHexTechChoiceRsp{
  // 待选的天赋列表等级
  int32 level = 2;
  // 此等级下可选的天赋tid列表
  repeated int32 hexTech = 3;
}

// 天赋选择请求
message MsgHexTechChoiceSelectReq{
  // 玩家控制的领主实体id
  uint64 entityId = 2;
  // 要选择天赋的等级（对应MsgHexTechChoiceRsp返回的等级）
  int32 level = 3;
  // 要选择的天赋的tid（对应MsgHexTechChoiceRsp.hexTech 列表中想要选择的那个天赋的值）（天赋tid对应CSVSpecialEffect.ID）
  int32 hexTech = 4;
}

message MsgHexTechChoiceSelectRsp{
  int32 level = 2;
}

enum ETeam{
  // 默认队伍（野队、无归属的建筑等...都属于这队）
  Team_None = 0;
  // 玩家队伍1
  Team1 = 1;
  // 玩家队伍2
  Team2 = 2;
  // 玩家队伍3
  Team3 = 3;
  // 玩家队伍4
  Team4 = 4;
  // 不存在的队伍，仅做合法性检测时使用
  Max = 5;
}

message MsgTeleportInfoNotify{
  uint64 entityId = 1;
  int32 startGridIdx = 2;
  int32 endGridIdx = 3;
  TeleportState state = 4;
  TeleportType type = 5;
  uint64 facilityId = 6;
}

enum TeleportState{
  TpState_None = 0;
  Start = 1;
  Break = 2;
  Finish = 3;
}

enum TeleportType{
  TpType_None = 0;
  WithLoading = 1;
  OneWay = 2;
  FlyCannonTeleport = 3;
}

message MsgEnemyPlayerPawnInfoNotify{
  repeated EnemyPlayerPawnInfo infos = 1;
}

message EnemyPlayerPawnInfo{
  uint64 entityId = 1;
  int64 recordTimeTicks = 2;
  repeated uint32 pawnDataIds = 3;
}

message CrystalRingInfo{
  // 城池对应的实体Id
  uint64 entityId = 1;
  // 城池当前的环数（对应类MOBA的内塔保护机制，在外塔未被推掉前无法攻击内塔）
  int32 maxRing = 2;
}

// 城池环数变更通知
message MsgCrystalRingNotify{
  // 城池环数变更数据
  CrystalRingInfo ringInfo = 1;
}

enum VisionType{
  // 普通侦查
  BaseScout = 0;
  // 普通隐蔽
  BaseHide = 1;
  // 进草丛导致的隐蔽
  GrassHide = 2;
  // 黑暗漫游（一个领主技能）导致的隐蔽
  DarkWandererHide = 3;
  // 埋伏导致的隐蔽
  AmbushHide = 4;
  // 隐身伞（一个领主技能）导致的隐蔽
  StealthUmbrellaHide = 5;
}

message MsgGunCarrierShellCastleNotify{
  uint64 entityId = 1;
  uint64 castleId = 2;
}

message MsgPlayerReviveNotify{
  uint64 entityId = 1;
  int64 revivalTime = 2;
  int64 buySquadCdEndTime = 3;
}

// ***视野信息变更通知
message MsgVisionInfoNotify{
  // 视野变更的实体id
  uint64 entityId = 1;
  // 变更的视野信息
  repeated VisionInfo visionInfos = 2;
}

// 视野变更信息
// 每一个视野属性都由两部分组成: 1. 视野范围: range（譬如半径0-1.5范围内）; 2. 视野等级: level
// 对于每个单位，其都有两个视野属性相关的集合: 1. 侦查视野集合: scoutVisionSet; 2. 隐蔽视野集合: hideVisionSet
// 假设有a, b两个单位，只有当a的“有效”最大侦查视野等级大于等于b的“有效”最大隐蔽视野等级时，b对a才是可见的。
// 即：当以下判定通过时，b对a才是可见。下列公式中的dis = Vector3.Distance(a.Position, b.Position)
// a.scoutVisionSet.Where(s => (dis >= s.range.Min && dis <= s.range.Max)).Max(scoutVision => scoutVision.level) >= 
// b.hideVisionSet.Where(h => (dis >= h.range.Min && dis <= h.range.Max)).Max(hideVision => hideVision.level)
message VisionInfo{
  // 视野距离[d1, d2, d3, d4, -1], 一个数组, 每个值表示一个距离值, 最后一个值-1为可选, 表示无穷远
  repeated float unitDistance = 1;
  // 视野等级[l1, l2, l3], 一个数组,数量永远为unitDistance的数量-1,表示在两个距离之间的等级,比如d1-d2距离之间的等级为l1
  repeated int32 level = 2;
  // 是否是移除视野
  bool isRemove = 3;
  // 是否为侦查视野
  bool isScout = 4;
  // 视野类型
  VisionType visionType = 5;
}

enum TeamShareEffectEntityType{
  RallyingFlag = 0;
}

message TeamShareEffectEntityInfo{
  TeamShareEffectEntityType eType = 1;
  uint64 entityId = 2;
  bool isRemove = 3;
  repeated float effectParams = 4;
}

message MsgTeamShareEffectEntityNotify{
  ETeam teamId = 1;
  repeated TeamShareEffectEntityInfo infos = 2;
}

enum ETipMsgType{
  Big = 0;
  Tiny_AtPos = 1;
  Tiny_OnSquadHud = 2;
}

enum EntityState{
  EntityState_None = 0;
  // 普通状态
  Normal = 1;
  // 战斗中
  Fighting = 2;
  // 死亡
  Dead = 3;
  // 历史遗留的状态, 玩家死亡后先进入这个状态
  NeedSetOnMap = 4;
  // 读条
  Loading = 5;
  // 埋伏
  Ambush = 6;
  // 暂时无用
  Fly = 7;
  // 暂时无用
  CannotFight = 8;
  // 待销毁
  Destroy = 9;
  // 霓冲刺 车头
  SprintHead = 10;
  // 霓冲刺 带人
  SprintFollower = 11;
  // 驻扎
  Garrison = 12;
}

message MsgTerritoryNotify{
  int32 gridIdx = 2;
  ETeam teamId = 3;
}

message MsgPingPongReq {

}

message MsgPingPongRsp {

}

message MsgConnectReq {
  string battleId = 1;   //新版连接 用battle 来定位哪一场战斗!!
  string address = 2;   //废弃 客户端不需要告知ip
  int32 port = 3;    //废弃 客户端不需要告知port
  bool onlyTcp = 4;
  string connectId = 5;  //玩家id的 tostring
  string token = 6;   //新版连接用token 确保玩家是本人
  bool isReconnect = 7;  //断线重连标志 默认false

}

message MsgConnectRsp {
  int64 token = 2;
  uint32 conv = 3;
  string address = 4;
  int32 port = 5;
  int32 clientId = 6;
}

enum PlayerState{
  DisConnect = 0;
  Connected = 1;
  Loaded = 2;
  Ready = 3;
}

message MsgPlayerJoinReq {
  PlayerState state = 2;
}

message MsgPlayerJoinRsp {
}

message MsgPlayerJoinNotify{
  string battleUniqueId = 1;
  uint64 playerEntityId = 2;
  ETeam teamId = 3;
  bool isCaptain = 4;
  string playerName = 5;
  int32 playerId = 6;
}

message MsgGameTimeNotify {
  int64 serverTimeTicks = 1;
}

message MsgSelectLordReq {
  int32 selectId = 2;
  int32 lockFlag = 3;
  int32 indexId = 4;
  int32 commandCount = 5;
}

message MsgSelectLordRsp {
}

message MsgSelectLordCoreCardReq{
  int32 indexId = 1;
  int32 commandCount = 2;
}

message MsgSelectLordCoreCardRsp{

}

message MsgSelectPlayerSkillReq{
  uint32 skillId = 1;
  int32 commandCount = 2;
}

message MsgSelectPlayerSkillRsp{

}

message MsgSelectPlayerFormationReq{
  uint32 formationId = 1;
  int32 commandCount = 2;
}

message MsgSelectPlayerFormationRsp{

}

message MsgChooseLordNotify{
  repeated int32 lordArray = 2;
  int64 endSelectLordTime = 3;
}

// 领主战斗单元信息
// 领主：棋盘格上受玩家控制，能够移动走格子，有模型表现的单元
// 战斗单元：领主触发战斗后，真正执行战斗的对象（即背包中可以配置上阵的单位）
message LordPawnInfo{
  // 战斗单元的tid（对应CSVPawn.Id）
  uint32 pawnId = 1;
  // 领主触发战斗后，此战斗单元被生成的战场位置标记
  int32 solt = 2;
}

message MsgSelectLordNotify{
  uint64 playerEntityId = 1;
  int32 lordId = 2;
  int32 skinId = 3;
  bool locked = 4;
  int32 coreCardIndexId = 5;
  uint32 playerSkillId = 6;
  repeated LordPawnInfo initFormation = 7;
}

message EntityChange {
  // true: 添加Entity; false: 移除Entity
  bool isAdd = 1;
  // 增/删 的EntityId
  uint64 entityId = 2;
  // 增/删 的Entity类型，对应EEntityType
  int32 entityType = 3;
}


// 实体改变通知
// 通知时机
// -1. 游戏状态发生改变时
// -2. 游戏内Entity 增/删 时（譬如加载完成后）
message MsgEntityNotify {
  // 实体改变（增/减）列表
  repeated EntityChange changeList = 2;
}

// 游戏状态改变通知
message MsgGameStateNotify {
  // 状态改变的起始时刻
  int64 stateStartTicks = 1;
  // 变化为的状态（对应EGameState）
  int32 state = 2;
}

// 资源信息
message ResourceInfo{
  // 持有者的实体id
  uint64 entityId = 1;
  // 当前金币数
  int32 coin = 2;
  // 当前领主经验值
  int32 food = 3;
  // 人口数（上阵可战斗单元将会消耗人口）
  int32 cost = 4;
  // 数据统计用
  int32 coinGain = 5;
  // 数据统计用
  int32 foodGain = 6;
  // 数据统计用
  int32 accCoin = 7;
}

// 资源信息同步消息
message MsgResourceNotify {
  // 资源信息
  ResourceInfo resourceInfo = 1;
}

// 单个背包物品信息
// 战斗单元在未进入战斗前，会被视为玩家背包中的一个物品存在
message BagItemData{
  // 物品tid（依据此物品的类型可能对应 CSVPawn.Id 或 CSVFragment.Id）
  uint32 dataId = 1;
  // 数量
  int32 count = 2;
  // 此物品的实体id（只有当其是pawn时才会有此id值）
  uint64 entityId = 3;
}

// 指定领主的背包物品信息
message BagInfo{
  // 领主的实体id
  uint64 entityId = 1;
  // 背包物品信息
  repeated BagItemData items = 2;
}
message MsgBagRsp{
}

// 玩家背包数据同步消息
message MsgBagNotify{
  BagInfo bagInfo = 1;
}

enum BagCommand
{
  Item_Sell = 0;  //卖道具 目前是只有 英雄和碎片
  Pawn_Sell = 1;  //卖 英雄及其碎片
}

// 出售卡牌请求
message MsgBagReq {
  // 战斗单元的tid（对应CSVPawn.Id）
  uint32 dataId = 2;
  // 出售的战斗单元个数（目前同种卡牌无法叠加，所以这个字段永远默认设1就行）
  int32 count = 3;
  // 出售的这个战斗单元的实体id（对应 BagItemData 同步下来的数据）
  uint64 entityId = 4;
  // 通过MsgPlayerCommandNotify同步到的当前指令次数
  int32 commandCount = 5;
  // 出售指令类型（当前版本已经从用户层面移除了碎片的概念，因此这个指令只会发出BagCommand.Pawn_Sell类型的操作）
  BagCommand command = 6;
}

// 血量信息
message HpInfo{
  // 实体id
  uint64 entityId = 1;
  // 当前血量
  float hp = 2;
  // 最大血量
  float maxHp = 3;
}

// ***血量变更通知
message MsgHpNotify {
  // 血量信息
  HpInfo hpInfo = 1;
}

message TeamInfo{
  uint64 entityId = 1;
  ETeam teamId = 2;
  bool isAlive = 3;
  repeated uint64 teamMember = 4;
  int32 homeIndex = 5;
  uint64 homeCrystalId = 6;
}

// 队伍状态改变通知，玩家状态改变时通知。目前为EGameState.WaitingPlayer后通知
message MsgTeamNotify{
  // 所有队伍信息
  repeated TeamInfo teamInfos = 1;
}

// 队伍“真家”改变通知
// 每一个队伍可能拥有多个“水晶”，当某个队伍拥有多个“水晶”时，其中只有一个会是被攻占后直接判定其所属小队失败的。我们称这样的“水晶”为“真家”
// 接受时机：
// -1. 对局刚开始，己方水晶创建后
// -2. 攻占了敌方的“真家”，并选择“迁都”后
message MsgTeamHomeChangeNotify{
  // “真家”所属的队伍实体id
  uint64 entityId = 1;
  // “真家”所在的地格下标
  int32 homeGridIdx = 2;
  // “真家”对应的建筑id
  uint64 castleId = 3;
}

message MsgGameOverNotify{
  repeated ETeam rankedTeams = 1;
}

// 待购买列表变更操作类型
enum PendingItemCommand{
  // 购买
  Item_Buy = 0;
  // 添加
  Item_Add = 1;
  // 刷新待购买列表
  Item_Refresh = 2;
  // 快速购买（自动执行“刷新待购买列表”，并“购买”所有需要的卡牌，直至没钱。相当于一键把当前剩余的钱全花光。）
  Quick_Buy = 3;
}

// 待购买列表的物品数据
message PendingItemData{
  // 数据下标
  int32 index = 1;
  // 数据的tid（对应CSVFragment.Id）
  uint32 dataId = 2;
  // 物品的数量
  int32 count = 3;
  // 购买的金币消耗量
  int32 coin = 4;
  // 是否已售出
  bool soldOut = 5;
}

message MsgPendingItemRsp{
}

// 待购买列表信息变更通知
// 待购买列表类似一个小型卡牌商店，玩家可以在这个列表中选择想要购买的卡牌购入，或者付费刷新此列表
message MsgPendingItemNotify{
  // 变更的待购买列表信息
  repeated PendingItemData items = 1;
  // 变更操作的类型
  PendingItemCommand commandId = 2;
}

// 商店刷新请求（当commandId不同时，需要配置的字段也会有所不同）
message MsgPendingItemReq{
  // 商店请求类型
  PendingItemCommand commandId = 1;
  // 购买操作时对应的 要购买的卡牌在商店列表中的下标（从协议上来说可以同时请求购买多个，但是对于真实用户而言，他们只能一个个点击购买）
  repeated int32 itemsIdx = 2;
  // 通过MsgPlayerCommandNotify同步到的当前指令次数
  int32 commandCount = 3;
}

enum ManageCastleCommand{
  LevelUp = 0;
  Dispose = 1;
}

message MsgManageCastleReq{
  ManageCastleCommand command = 2;
  uint64 entityId = 3;
  int32 commandCount = 4;
}

//暂时回复一个空的
message MsgManageCastleRsp
{

}

message CastleInfo{
  // 建筑对应的实体Id
  uint64 entityId = 1;
  // 建筑对应的建筑Id
  uint32 castleId = 2;
  // 建筑所属的队伍实体Id
  uint64 ownerId = 3;
}

// 建筑信息改变通知（可能是 创建/移除/改变）
message MsgCastleNotify{
  // 所有改变了的建筑信息
  repeated CastleInfo infos = 1;
}

// 通知建筑所属的队伍 建筑信息变动
message MsgCastleOwnerNotify{
  // 建筑所属的队伍实体Id
  uint64 entityId = 1;
  // 产生变动的建筑实体Id
  repeated uint64 castleIds = 2;
}

// 领主信息同步消息
message MsgLordNotify{
  repeated LordSyncInfo lordInfos = 2;
}

// 场域信息
// 场域：即棋盘格中指定规则的格子组成的一块区域。与常规概念下的“触发区域类似”，只是它是由离散的格子组成的
// 用于处理与范围相关的功能逻辑。它能够拥有可见的模型/特效表现，也可以是没有表现部分的纯逻辑单元
message FieldInfo{
  // 场域对应的实体id
  uint64 entityId = 1;
  // 场域的tid（对应CSVField.Id）
  uint32 fieldId = 2;
  // 所属的队伍id
  ETeam teamId = 3;
  // 其持有者的实体id（通常场域都被某个Player Entity所持有）
  uint64 ownerEntityId = 4;
  // 用户自定义数据（对于不同的场域实现，此字段对应的含义也不相同）
  repeated float customData = 5;
}

message MsgFieldNotify{
  // 收到的场域信息
  repeated FieldInfo infos = 1;
}

// 领主数据同步消息
message LordSyncInfo{
  // 领主实体id
  uint64 entityId = 1;
  // 领主id（对应CSVLord.Id）
  int32 lordId = 2;
  // 皮肤id（对应CSVGSLordSkin.ItemID）
  int32 skinId = 3;
  // 领主技能id（对应CSVSkill.Id）
  uint32 skillId = 4;
  // 初始阵容信息
  repeated LordPawnInfo initFormation = 5;
}

message Position{
  int32 x = 1;
  int32 y = 2;
  int32 z = 3;
}

message Forward{
  int32 x = 1;
  int32 y = 2;
  int32 z = 3;
}

// 状态信息（主要是位置、单位状态）
message PhysicsInfo{
  // 所属的实体id
  uint64 entityId = 1;
  // 在棋盘格上的位置
  Position position = 2;
  // 在棋盘格上的朝向
  Forward forward = 3;
  // 当前的位置变动是否是由传送导致的
  bool isTeleport = 4;
  // 
  EntityState state = 5;
  // 
  int64 stateChangeTime = 6;
  // 
  int64 stateEndTime = 7;
  // 
  repeated EntityState stateChangeList = 8;
}

// ***核心状态信息通知
message MsgPhysicsNotify{
  // 状态信息
  repeated PhysicsInfo physicsInfos = 2;
}

// 野队信息（在游戏中，“野队”是类似于玩家操控的“领主”一样的存在。它在棋盘格中拥有一个自己的模型表现，并能够在触碰到后与之进入一场战斗）
message SquadInfo{
  // 野队的实体Id
  uint64 entityId = 1;
  // 野队的tid（对应CSVSquad.Id）
  uint32 squadId = 2;
  // 暂时无用
  uint64 ownerPlayerId = 3;
  // 战胜此野队后所能获得的奖励buff tid列表（对应CSVBuff.Id）
  repeated uint32 fightRewardBuffs = 4;
}

// 野队信息通知
message MsgSquadNotify{
  // 所有收到的需要更新的野队信息
  repeated SquadInfo squadInfos = 1;
}

// 地格功能实体信息
// “地格功能实体”是一种应用于棋盘格上，为了辅助实现某些棋盘格功能而存在的实体
message GridPropInfo{
  // 其对应的实体id
  uint64 entityId = 1;
  // 其对应的tid（对应CSVGridProp.Id）
  uint32 dataId = 2;
  // 持有它的玩家playerId（如果有持有者的话）
  uint64 playerId = 3;
  // 共享视野半径（在此视野范围内其它队伍将会获得无视战争迷雾的视野）
  int32 overrideVisionSize = 5;
  // 当下是否可用（有的“地格功能实体”拥有被使用的能力）
  bool disableUse = 6;
  // 其被创建的时刻（有的“地格功能实体”可能存在生命周期）
  int64 timeCreate = 7;
  // 与“timeCreate”相配套，服务于其存在的生命周期
  int64 timeExpectedChange = 8;
  // 暂时无用
  int32 period = 9;
  // 其归属的队伍实体id
  uint64 teamEttId = 10;
}

// 地格功能实体信息改变通知
message MsgGridPropNotify{
  // 收到的所有发生改变的地格功能实体信息列表
  repeated GridPropInfo gridPropInfos = 1;
}

// 通知野队的归属者 野队所属信息发生变动
message MsgSquadOwnerNotify{
  // 野队所属的队伍实体Id
  uint64 entityId = 1;
  // 产生变动的野队实体Id
  repeated uint64 squadIds = 2;
}

// 战斗单元信息
message PawnInfo{
  // 此战斗单元的实体id
  uint64 entityId = 1;
  // 此战斗单元的tid（对应CSVPawn.Id）
  uint32 dataId = 2;
  // 持有此战斗单元的 野队/领主 实体id
  uint64 squadId = 3;
}

// 战斗单元信息通知
message MsgPawnNotify{
  // 战斗单元信息
  repeated PawnInfo pawnInfos = 1;
}

// 战斗单元信息
message MsgPawnSoltInfo
{
  // 此战斗单元在战斗格上的位置标记
  int32 solt = 1;
  // 此战斗单元的tid（对应CSVPawn.Id）
  uint64 pawnId = 2;
}

// 通知战斗单元持有者战斗单元数据
message MsgPawnsOwnerNotify{
  // 战斗单元持有者的实体id
  uint64 entityId = 1;
  // 此持有者持有的所有战斗单元信息
  repeated MsgPawnSoltInfo pawns = 2;
}

enum EditSquadCommand{
  MovePawn = 0;
  LevelUpEntity = 1;
  ReviveSquad = 3;
  ChangeRainbowCard = 4;
}

// 布阵编辑请求
message MsgEditSquadReq{
  // 目前此请求只有 MovePawn 一种类型是实际有使用的，因此此条请求可以看做“阵容调整请求”（包括 上阵、下阵、调整位置）
  EditSquadCommand command = 2;
  // 被调整的战斗单元的实体id（对应 BagItemData 同步下来的数据: entityId）
  uint64 sourceEntityId = 3;
  // 持有这个战斗单元的领主实体id（通过BagInfo能够获取到战斗实体与领主的持有关系）
  // 战斗单元作为BagItemData记录在背包中，背包的持有者BagInfo.entityId即这些战斗单元的持有者（也就是玩家控制的领主）
  uint64 targetEntityId = 4;
  // 要移动到的沙盘格目标点位。在操作为 上阵、调整位置 时需要填；在操作为 下阵 时无需填
  // 坐标点位为 从上往下，从左往右，以0为起始值的int值标记。（即打开背包后的布阵格子下标对应关系如下）
  // x 4 8  ... x
  // 1 5 9  ... 29
  // 2 6 10 ... 30
  // x 7 11 ... x
  int32 targetSlotId = 5;
  int32 commandCount = 6;
}

message MsgEditSquadRsp
{}

enum OrderSquadCommand{
  ReRoll = 0;
  Scout = 2;
  Born = 4;
  CastleTeleport = 5;
  Cancel = 6;
  CardTechLevelUp = 7;
  EconomyTechLevelUp = 8;
  UsePortal = 9;
  OneWayTeleport = 11;
  GrowRadish = 12;
  CollectRadish = 13;
  FlyCannon = 14;
}

// command: ReRoll
// - 有效字段只有[command, commandCount]
// - 包体示例{"command": OrderSquadCommand.ReRoll, "commandCount": 1546}
message MsgOrderSquadReq{
  // 目前这个消息只有投骰子一个应用场景
  OrderSquadCommand command = 2;
  uint64 squadEntityId = 3;
  uint64 commandParam = 4;
  repeated int32 extraParams = 5;
  // 通过MsgPlayerCommandNotify同步到的当前指令次数
  int32 commandCount = 6;
}

message MsgOrderSquadRsp
{
  OrderSquadCommand command = 1;
}

// ap信息
// ap: 骰子数。一个骰子数可以执行一次投骰子。
// rp: 移动点数。投一次骰子，其投出的点数即算入玩家当前的剩余可移动点数
message ApInfo{
  // 此信息的持有者实体id
  uint64 entityId = 1;
  // 最大可囤积的骰子数
  int32 maxAp = 2;
  // 当前持有的骰子数
  int32 currentAp = 3;
  // 剩余的移动点数
  int32 restRp = 4;
  // 
  bool canAttack = 5;
  // 
  bool movable = 6;
  // 
  bool canTeleport = 7;
  // 
  bool hasRush = 8;
  // 
  bool canScout = 9;
  // 
  bool canAmbush = 10;
  // 
  int64 nextApTick = 11;
  // 可投出的最小移动点数（每次投骰子，最小值不会小于此值）
  int32 minRp = 12;
  // 可投出的最大移动点数（每次投骰子，最大值不会大于此值）
  int32 maxRp = 13;
  // 获得一个骰子的间隔时间
  float apInterval = 14;
}

// ap数据变更通知
message MsgApNotify{
  // ap数据
  ApInfo apInfo = 1;
}

/*
	已废弃
*/
message DpInfo{
  uint64 entityId = 1;	// 玩家实体id
  int32 currentDp = 2;	// 当前骰子数
  int32 maxDp = 3;		// 最高骰子数
}

/*
	已废弃消息
*/
message MsgDpNotify{
  DpInfo dpInfo = 1;
}

// ***路径改变通知
// 棋盘格中的单位要移动，首先要先生成一个可移动路径，然后才会开始移动
message MsgPathNotify{
  // 路径数据的持有者实体id
  uint64 entityId = 1;
  // 路径信息
  PathInfo pathInfo = 2;
}

// 路径信息
message PathInfo{
  // 移动类型（对应EPathMoveType。包含{Normal: 按照事先排好的地格列表寻路, Direction: 按照某个特定的方向寻路}）
  int32 moveType = 2;
  // Normal类型下的路径地格下标列表
  repeated int32 path = 3;
  // Direction类型下的X轴数据
  float dirX = 4;
  // Direction类型下的Z轴数据
  float dirZ = 5;
  // 后端的移动速度
  float modelAcc = 6;
  // 抵达路径终点后的行为（对应EPathGoalBehavior。包含{None: 什么都不干, Attack: 攻击, Push: 移动过程中撞到地方单位不进战（原地停止）}）
  int32 afterGoalBehavior = 7;
}

// buff数据
message BuffData{
  // buffTid（对应CSVBuff.Id）
  uint32 buffId = 1;
  // buff移除的时刻
  int64 buffEndTime = 2;
  // 配置参数（CSVBuff表中formatParams列配置的数据）
  repeated float param = 3;
  // 特定功能buff的额外数据（目前用作堆叠数）
  repeated float details = 4;
}

// buff同步消息
message MsgBuffNotify{
  // 所属的实体id
  uint64 entityId = 2;
  // buff数据列表
  repeated BuffData buffList = 3;
  // 移除的buffTid列表（对应CSVBuff.Id）
  repeated uint32 canceledList = 4;
}

message BattleBuffData{
  uint32 battleBuffId = 1;
  uint64 endTick = 2;
  float detail = 3;
}

message MsgBattleBuffNotify{
  uint64 entityId = 1;
  repeated BattleBuffData battleBuffList = 2;
  uint64 Tick = 3;
}

message MsgKcpConnectReq{
}

message MsgKcpConnectRsp{
}


message MsgScoutResultNotify{
  uint64 scoutSquadId = 1;
  repeated uint64 pawnIds = 2;
}

message MsgSkillResultNotify{
  uint64 owner = 1;
  repeated uint64 targets = 2;
  repeated int64 resultParams = 3;
  bool stop = 4;
  int32 index = 5;
}

// 技能数据
message SkillData{
  // 持有者的实体id
  uint64 entityId = 1;
  // 技能类型
  uint32 buffType = 2;
  // 技能的tid（对应CSVSkill.Id）
  uint32 dataId = 3;
  // 冷却完毕的时刻
  int64 coolDownEndTime = 4;
  // 已使用的次数
  int32 usedCount = 5;
  // 
  int32 stackCount = 6;
  // 技能阶段（有的技能可能有多个阶段，譬如读条阶段，持续释放阶段等）
  int32 skillPhase = 7;
  int64 availableEndTime = 8;
  int64 durationEndTime = 9;
  float customData = 10;
  // 当前技能在持有者技能列表中的下标
  int32 skillIndex = 11;
}

message MsgSkillSyncRsp{
  int32 skillIndex = 1;
  int32 targetGridIdx = 2;  // 技能选中格子
  uint64 targetEntity = 3;  // 技能选中的目标
}

// 技能数据变更通知
message MsgSkillSyncNotify{
  repeated SkillData skillData = 1;
}

message MsgSkillRemoveNotify{
  uint64 entityId = 1;
  uint32 skillIndex = 2;
}

// 发起技能请求
// 目前的技能大体有两种释放逻辑
// 1. 选定目标实体进行释放，只需配置targetEntity（譬如鲨鱼的钩子，必须要选定一个敌方领主才能释放）
// 2. 选定地格进行释放，只需配置targetGridIdx（譬如小狗的传送门，选中的是一个地格，而非领主）
message MsgSkillSyncReq{
  // 当前技能在玩家技能槽中的下标（许多功能的底层都是直接通过技能实现的，譬如领主专属技能、回城、侦查...等。对于用户而言，可能最终接入这些技能的入口有多个，而每一个可能的入口则对应一个这样的槽位下标。具体的槽位类型如下：）
  // Lord = 0, // 领主技能
  // Common = 1, // 通用技能：回城
  // Summoner = 2, // 召唤师技能
  // GunCarrier = 3, // 炮车怪技能
  int32 skillIndex = 1;
  // 技能的tid（对应CSVSkill.Id）
  uint32 dataId = 2;
  // 技能选中格子
  int32 targetGridIdx = 5;
  // 技能选中的目标实体id
  uint64 targetEntity = 6;
  repeated uint64 skillParams = 3;
  // 通过MsgPlayerCommandNotify同步到的当前指令次数
  int32 commandCount = 4;
}

enum PlayerAttribute{
  RefreshCoin = 0;
  FreeAwardDelta = 1;
  FreeDrawDelta = 2;
  LevelUpCastleCostRate = 3;
  ResourceGainRatio = 4;
  GainExtraAdd = 5;
  FoodExtraAdd = 6;
  RefreshCoinDiscount = 7;
  FrageValueRate = 8;          // 卡牌价值(0~1)
  PawnLvUpLimit = 9;           // pawn卡片等级上限 指代表减少的等级上限
  ExtraExpRate = 10;           // 所有获得的经验，提高对应数值的百分比 (0~1)
  ExtraCoinRate = 11;          // 所有获得的金钱，提高对应数值的百分比 (0~1)
  ExtraWinRecoverRate = 12;    // 战斗胜利后，额外回复最大生命值的百分比 (0~1)
  ExtraLooseRecoverRate = 13;  // 撤退结算，额外回复最大生命值的百分比 (0~1)
  DrawCardCirt = 14;           // 抽卡暴击率
  SellFrageValueRate = 15;     // 卡片贩卖价值收益(0~1)
  CoinModifyRate = 16;         // 除卖卡外所获得的金钱，其真实获取所要做的修正值的百分比 (0~1)。与ExtraCoinRate的不同在于，此属性对于金币的修改不会影响其经济展示数值
  
  DrawCardCombo1 = 21;
  DrawCardCombo2 = 22;
  DrawCardCombo3 = 23;
  DrawCardCombo4 = 24;
  DrawCardCombo5 = 25;
  DrawCardCombo6 = 26;
  DrawCardCombo7 = 27;
  DrawCardCombo8 = 28;
  DrawCardCombo9 = 29;
  DrawCardCombo10 = 30;
}

message MsgPlayerAttributeData{
  PlayerAttribute attributeId = 1;
  int64 value = 2;
  bool isRemove = 3;
}

message MsgPlayerAttributeChangeRsp{

}

message MsgPlayerAttributeChangeNotify{
  uint64 entityId = 1;
  repeated MsgPlayerAttributeData data = 2;
}

message MsgPlayerAttributeChangeReq{
  uint64 entityId = 2;
  repeated MsgPlayerAttributeData data = 3;
}


message MsgShowMessageNotify{
  int32 id = 1;
  repeated string args = 2;
  ETipMsgType tipType = 3;
  uint64 entityId = 4;
}

message MsgDefeatNotify{
  int32 rank = 1;
  ETeam winnerTeamId = 2;
  ETeam loserTeamId = 3;
}

message MsgKillBossNotify{
  uint64 entityId = 1;
}

message MsgDisconnectReq{
}

message MsgDisconnectNotify{
}

message MsgMoveCrystalReq{
  bool isAgree = 1;
  int32 position = 2;
  int32 commandCount = 3;
}

message MsgMoveCrystalRsp{
}

message GmInfo{
  int32 level = 1;
  string info = 2;
}

message MsgEnterGameNotify{
}

enum ModifyBattleUnitCommandType{
  Add = 0;
  Remove = 1;
  ChangePlayer = 2;
  MovePos = 3;
}

message MsgModifyBattleUnitReq{
  ModifyBattleUnitCommandType commandType = 2;
  uint64 entityId = 3;
  uint32 battleUnitDataId = 4;
  int32 gridIndex = 5;
  uint64 ownerId = 6;
}

//暂时回复一个空的
message ModifyBattleUnitRsp
{
}

message MsgAddBattleUnitsReq{
  uint64 entityId = 2;
  string battleUnits = 3;
}

message AddBattleUnitsRsp
{
}


enum SimulateBattleMapReqCommandType{
  Simulate = 0;
  SimulateWithoutShow = 1;
}

message MsgSimulateBattleMapReq{
  SimulateBattleMapReqCommandType commandType = 2;
  string command = 3;
}

message SimulateBattleMapRsp
{
}

enum BattleMapControlCommandType{
  Map_Create = 0;
  Map_Clear = 1;
  Map_Remove = 2;
  Map_Play = 3;
  Map_Pause = 4;
}

message MsgBattleMapControlReq{
  BattleMapControlCommandType command = 2;
  uint64 param = 3;
}

message MsgBattleMapControlRsp
{
}

/*
战斗单位信息
*/
message MsgBattleUnitInfo{
  uint64 entityId = 1;				//战斗单位实体id
  uint32 battleUnitDataId = 2;		//战斗单位数据id
  Position position = 3;			//小常常位置
  uint64 battleMap = 4;				//小战场id
  uint64 ownerId = 5;				//拥有者id
  int32 teamId = 6;					//拥有者team
  uint32 originPawn = 7;			//原始pawn
  bool isAdditional = 8;			//是否是额外的
}

/*
	复数战斗单位信息通知
*/
message MsgBattleUnitNotify{
  repeated MsgBattleUnitInfo infos = 1;
}

message MsgBattleCreationInfo{
  uint64 entityId = 1;
  uint32 battleCreationDataId = 2;
  Position position = 3;
  uint64 battleMap = 4;
  uint64 ownerId = 5;
  int32 teamId = 6;
}

message MsgBattleCreationAddNotify{
  repeated MsgBattleCreationInfo infos = 1;
}

// 入战方位
// 对于每一个进入战斗的队伍而言，它们都需要确定一个入战方位。这个入战方位将会确定它们最终将会被生成在哪里
// 每一个战斗战场都有留个战斗方位，它们分别是下面的这几个
// 假设a是进攻方，d是防守方，s是d的队友。a向d发起了一场战斗,然后s从这个战场周围任意一格进入支援这场战斗，s对应的入战方位大体如下
// 其中a的入战方位为(0),d的入战方位为(1)
// 
// (4)(4)(4)
// (2)(d)(3)
// (2)(a)(3)
// (5)(5)(5)
enum CoreBattleMapPosition{
  // 攻击方
  Attacker = 0;
  // 防守方
  Defender = 1;
  // 左侧支援
  SupporterLeft = 2;
  // 右侧支援
  SupporterRight = 3;
  // 上方支援
  SupporterUp = 4;
  // 下方支援
  SupporterDown = 5;
}

// 加入战斗的玩家信息
message MsgBattleMapJoinedInfo{
  // 加入战斗的领主实体id
  uint64 joinedEntityId = 1;
  // 加入战斗的方位
  CoreBattleMapPosition mapPosition = 2;
  // 加入战斗的时刻
  uint64 joinedTime = 3;
  // 当前的总hp
  uint32 totalHp = 4;
  // 埋伏类型
  AmbushType ambushType = 5;
}

// 埋伏类型
enum AmbushType{
  // 被埋伏
  IsAmbushed = 0;
  // 主动埋伏中
  Ambushing = 1;
  // 加入埋伏的对战
  JoinAmbush = 2;
  // 无埋伏
  NoAmbush = 3;
}

message RedDotNotifyData{
  int32 id = 1;
  int64 startTs = 2;
  int32 styleData = 3;
  bool hasCertified = 4;
}

// 加入战斗的队伍信息
message MsgBattleMapTeamPlayers{
  // 队伍id
  ETeam teamId = 1;
  // 当前队伍下的玩家领主实体id
  repeated uint64 players = 2;
}

message MsgBattleMapFleeFinishNotify{
  uint64 entityId = 1;
}

///重要消息 通知战斗结果
message MsgBattleMapResultNotify{
  uint64 entityId = 1;					//通知的战斗实体id
  repeated uint64 restPlayers = 2;		//战场剩余的玩家	
  repeated uint64 winnerPlayers = 3;	//获胜的玩家	
  repeated uint64 losePlayers = 4;		//失败的玩家
  repeated uint64 drawPlayers = 5;		//战平的玩家	
  uint64 castleId = 6;					//如果在城堡中战斗 城堡的id 没有即为0
  ETeam winnerTeamId = 7;				//获胜的队伍id
  uint64 endTick = 8;					//小战斗开始到结束的时间（从0开始）
  int64 endTimeTick = 9;				//游戏开始到这场战斗结束的时间（从0开始）
}

// 战场信息更新通知
message MsgBattleMapNotify{
  // 战场实体的id
  uint64 entityId = 1;
  // 发生战斗的地格下标
  repeated int32 happenedGridIndex = 2;
  // 对应[Flags]FightType。包含{Pvp: 玩家对抗, CastleFight: 包含建筑的战斗, AmbushFight: 埋伏战斗, OneOnOneFight: 一对一战斗}
  int32 fightType = 3;
  // 所有加入战斗的玩家信息
  repeated MsgBattleMapJoinedInfo joinedInfos = 4;
  // 所有加入战斗的队伍信息
  repeated MsgBattleMapTeamPlayers teamPlayers = 5;
}

message MsgBattleMapPlayerNotify{
  uint64 entityId = 1;
  repeated MsgBattleMapJoinedInfo joinedInfos = 2;
  repeated int32 happenedGridIndex = 3;
  repeated MsgBattleMapTeamPlayers teamPlayers = 4;
}

enum EBattleMapEventType{
  LordEnter = 0;
  LordSupport = 1;
  LordDamage = 2;
  LordKill = 3;
  LordFleeStart = 4;
  LordFleeFinish = 5;
}

message MsgBattleMapEventNotify{
  uint64 entityId = 1;
  uint64 tick = 2;
  EBattleMapEventType eventType = 3;
  uint64 entitySponsor = 4;
  repeated uint64 entityTargets = 5;
  int32 gridIdx = 6;
  float eventParam = 7;
  repeated bool entityAttakerFlag = 8;
}

message BattleUnitFledInfo{
  uint64 battleUnitEttId = 1;
  float restHp = 2;
}

message BattleEntityFledInfo{
  uint64 battleEntityEttId = 1;
  repeated BattleUnitFledInfo info = 2;
  bool fleeFinished = 3;
}

message MsgBattleMapFledInfoNotify{
  uint64 battleMapEntityId = 1;
  repeated BattleEntityFledInfo info = 2;
}

enum BattleUnitStateType{
  BattleUnitState_None = 0;
  Idle = 1;
  Move = 2;
  BattleUnitState_Attack = 3;
  Special = 4;
  Flee = 5;
  Die = 6;
  Stun = 7;
  Hitback = 8;
  Removed = 9;
}

enum BattleDmgType{
  Dmg = 0;				//伤害
  Heal = 1;				//治疗
  CriticalDmg = 2;		//暴击伤害 
}


/*
	战斗伤害信息（此消息只是表现型消息 可以不用处理）
*/
message MsgBattleDmgInfo {
  uint64 entityId = 1;			//战斗单位实体id
  uint64 frameTick = 2;			//帧数
  BattleDmgType dmgType = 3;	//伤害类型
  uint32 value = 4;				//具体数值
  uint32 preTaxValue = 5;		//未计算前的数值
  uint64 attackId = 6;			//攻击对象实体id（也是战斗内的）
}

/*
	复数战斗伤害信息通知
*/
message MsgBattleDmgNotify{
  repeated MsgBattleDmgInfo infos = 2;
}

message MsgAttackCastleNotify{
  ETeam teamId = 2;
  uint64 attackId = 3;
  uint64 takerId = 4;
}

message MsgHitbackInfo {
  uint64 startTick = 1;
  float time = 2;
  Position startPos = 3;
  Position endPos = 4;
  uint32 speedHorizontal = 5;
  float hitFlyHeight = 6;
  float flyUpTime = 7;
  float flyingTime = 8;
  float flyDownTime = 9;
}

message MsgBattleUnitStateInfo {
  uint64 entityId = 1;
  BattleUnitStateType state = 2;
  uint64 battleMapTime = 3;
  uint64 param = 4;
  Position position = 5;
  Position targetPosition = 6;
  uint32 skillId = 7;
  repeated uint64 skillTargets = 8;
  MsgHitbackInfo hitbackInfo = 9;
}

message MsgBattleUnitStateNotify{
  repeated MsgBattleUnitStateInfo infos = 2;
}

enum BattleUnitMoveInfoType{
  ToCell = 0;
  ToPos = 1;
}


/*
	战斗单位移动信息
*/
message MsgBattleUnitMoveInfo {
  uint64 entityId = 1;						//战斗单位实体id
  BattleUnitMoveInfoType infoType = 2;		//是移动到格子还是移动到位置	
  int32 nextCellId = 3;						//下一个格子id	
  Position toPos = 4;						//移动到的位置 (x,y,z)
}


/*
	复数战斗单位移动信息通知
*/
message MsgBattleUnitMoveNotify{
  repeated MsgBattleUnitMoveInfo infos = 2;
}



message MsgBattleInstantSkillInfo {
  uint64 entityId = 1;
  uint64 battleMapTime = 2;
  uint32 skillId = 3;
  repeated uint64 skillTargets = 4;
}

message MsgBattleInstantSkillNotify{
  repeated MsgBattleInstantSkillInfo infos = 2;
}

enum BattlePlayerCommandType{
  Player_Flee = 0;
}

message MsgBattlePlayerCommandReq{
  uint64 battleMapEntityId = 1;
  uint64 entityId = 2;
  BattlePlayerCommandType command = 3;
  int32 commandCount = 4;
}

message MsgBattlePlayerCommandRsp
{
}

message MsgBattleMapTimerNotify{
  uint64 entityId = 2;
  uint64 frameTick = 3;
  bool isPause = 4;
}

enum BattleAttribute
{
  Hp = 0;
  BasicHp = 1;
  Mp = 2;
  MaxMp = 3;
  Speed = 4;
  Attack = 5;
  Defend = 6;
  AttackRange = 7;
  AttackSpeed = 8;
  AttackGainMp = 9;
  DamageGainMp = 10;
  CriticalRate = 11;
  CriticalDamageRate = 12;
  PerHp = 13;
  PerAttack = 14;
  PerDefend = 15;
  AdditiveDefend = 16;
  PerAttackSpeed = 17;
  AdditiveAttackRange = 18;
  PerMoveSpeed = 19;
  AdditiveEnergy = 20;
  TakeDamageIncrease = 21;
  DamageTakenDecrease = 22;
  SuckBloodRate = 23;
  HealTakenIncrease = 24;
  Toughness = 25;
  SkillDamageIncrease = 26;
  BasicModelScale = 27;
  PerModelScale = 28;
  MaxHP = 100;
  CurAttack = 101;
  CurDef = 102;
  CurAttackSpeed = 103;
  CurAttackRange = 104;
  CurMoveSpeed = 105;
  CurModelScale = 106;
}

message MsgBattleUnitAttributeItem{
  BattleAttribute attribute = 1;
  float value = 2;
}

message MsgBattleUnitAttributeInfo{
  uint64 entityId = 1;
  repeated MsgBattleUnitAttributeItem attributes = 2;
  uint64 frameTick = 3;
  bool takeCriticalDmg = 4;
}

message MsgBattleUnitAttributeNotify{
  repeated MsgBattleUnitAttributeInfo battleUnitAttributes = 2;
}

// 玩家信息
message PlayerInfo{
  // 玩家控制的领主EntityId
  uint64 entityId = 1;
  // 玩家所属的队伍Id
  ETeam teamId = 2;
  // 暂时无用
  bool isCaptain = 3;
  // 玩家名
  string playerName = 4;
  // 玩家Id
  int32 playerId = 5;
  // userId
  string userId = 6;
  // 当前的KDA数据
  repeated KDAValue kda = 7;
}

message MsgPlayerNotify{
  repeated PlayerInfo playerInfos = 1;
}

message MsgBattleMapSetPlayerInfoReq{
  uint64 mapEntityId = 2;
  uint64 ownerId = 3;
  float hpPercent = 4;
}

message MsgBattleMapSetPlayerInfoRsp
{
}

message AmbushInfo{
  uint64 entityId = 1;
  int32 ambushGridIdx = 2;
  AmbushState state = 3;
}

message MsgAmbushNotify{
  AmbushInfo ambushInfo = 1;
}

enum AmbushState{
  No_Ambush = 0;
  Loading_Ambush = 1;
  Finish_Ambush = 2;
}

enum ChatChannel{
  All = 0;
  Chat_Team1 = 1;
  Chat_Team2 = 2;
  Chat_Team3 = 3;
  Chat_Team4 = 4;
}

message MsgNormalChatReq{
  ChatChannel channel = 2;
  string message = 3;
}

message NormalChatContent{
  int32 playerId = 1;
  uint64 frameTick = 2;
  ChatChannel channel = 3;
  string message = 4;
}

message MsgNormalChatRsp{
}

message MsgNormalChatNotify{
  repeated NormalChatContent chatList = 1;
}

enum ParamChatType{
  Mark = 0;
  Pawn = 1;
  QuickMsg = 2;
  Emoji = 3;
}

message ParamChatContent{
  int32 playerId = 1;
  uint64 frameTick = 2;
  ChatChannel channel = 3;
  ParamChatType chatType = 4;
  uint64 chatParam1 = 5;
  uint64 chatParam2 = 6;
}

message MsgParamChatReq{
  ChatChannel channel = 2;
  ParamChatType chatType = 3;
  uint64 chatParam1 = 4;
  uint64 chatParam2 = 5;
}

message MsgParamChatRsp{
}

message MsgParamChatNotify{
  repeated ParamChatContent chatList = 1;
}

// 玩家指令数同步消息（各种Command请求需要发送此信息，用于验证Command的合法性）
message MsgPlayerCommandNotify{
  // 当前生效过的指令次数
  int32 commandCount = 2;
}

message JoinBattleUnitInfo{
  uint64 entityId = 1;
  uint32 battleUnitDataId = 2;
  uint32 posX = 3;
  uint32 posY = 4;
  uint64 ownerId = 5;
  int32 teamId = 6;
  uint32 originPawn = 7;
  repeated MsgBattleUnitAttributeItem attributes = 8;
  BattleUnitStateType state = 9;
  uint64 param = 10;
  Position targetPosition = 11;
  float stateCoolDown = 12;
  uint32 overrideActiveSkillId = 13;
}

message MsgJoinBattleNotify{
  uint64 battleMap = 1;
  uint64 frameTick = 2;
  repeated JoinBattleUnitInfo unitInfos = 3;
}

message MsgGmCommandReq{
  string funcName = 2;
  repeated string para = 3;
}

message MsgTutorialCommandReq{
  string funcName = 2;
  repeated string para = 3;
}

message ReconnectGameContext{
  int64 gameStateStartTicks = 1;
  int32 gameState = 2;
  repeated CrystalRingInfo ringInfos = 4;
  int64 gameTimeTicks = 5;
  repeated SpawnerInfo spawnerInfos = 6;
}

message ReconnectTeamInfo{
  TeamInfo teamInfo = 1;
  ResourceInfo resourceInfo = 2;
  int32 winnerScore = 3;
  TeamTechInfo teamTechInfo = 4;
  repeated uint64 castleIds = 5;
  repeated uint64 squadIds = 6;
}

message PlayerReviveInfo{
  int64 revivalTime = 1;
  int64 buySquadCdEndTime = 2;
}

message ReconnectPlayerInfo{
  PlayerInfo playerInfo = 1;
  PhysicsInfo physicsInfo = 2;
  HpInfo hpInfo = 3;
  int32 lordId = 4;
  ResourceInfo resourceInfo = 5;
  repeated VisionInfo visionInfo = 6;
  repeated MsgPawnSoltInfo pawns = 7;
  repeated SkillData skill = 8;
  repeated BuffData buffData = 9;
  TeamTechInfo playerTechInfo = 10;
  int32 skinId = 11;
  AmbushInfo ambushInfo = 12;
  PlayerReviveInfo playerReviveInfo = 13;
  uint32 skillId = 14;
  PathInfo pathInfo = 15;
  PlayerVisInfo visInfo = 16;
}
message ReconnectPawnInfo{
  PawnInfo pawnInfo = 1;
  repeated BuffData buffData = 2;
}
message ReconnectCastleInfo{
  CastleInfo castleInfo = 1;
  PhysicsInfo physicsInfo = 2;
  HpInfo hpInfo = 3;
  repeated VisionInfo visionInfo = 4;
  int32 winnerScore = 5;
}
message ReconnectSquadInfo{
  SquadInfo squadInfo = 1;
  PhysicsInfo physicsInfo = 2;
  HpInfo hpInfo = 3;
  repeated VisionInfo visionInfo = 4;
  repeated BuffData buffData = 5;
}

message ReconnectFieldInfo{
  FieldInfo fieldInfo = 1;
  PhysicsInfo physicsInfo = 2;
  repeated VisionInfo visionInfo = 3;
}

message ReconnectGridPropInfo{
  GridPropInfo gridPropInfo = 1;
  PhysicsInfo physicsInfo = 2;
  repeated VisionInfo visionInfo = 3;
}
message ReconnectSelfPlayerInfo{
  uint64 entityId = 1;
  int32 commandCount = 5;
  repeated PendingItemData pendingItems = 6;
  uint64 selfTeamId = 7;
  repeated EnemyPlayerPawnInfo enemyPlayerPawnInfos = 8;
  int32 restSurrenderCount = 9;
  repeated MsgPlayerAttributeData attrDatas = 10;
  MoveCrystalInfo moveCrystalInfo = 11;
}

message ReconnectSelfTeamMemberInfo{
  ApInfo apInfo = 1;
  BagInfo bagInfo = 2;
  DpInfo dpInfo = 3;
}

message MsgReconnectInfoNotify{
  ReconnectGameContext context = 1;
  repeated ReconnectTeamInfo teamInfos = 2;
  repeated ReconnectPlayerInfo playerInfos = 3;
  repeated ReconnectPawnInfo pawnInfos = 4;
  repeated ReconnectCastleInfo castleInfos = 5;
  repeated ReconnectSquadInfo squadInfos = 6;
  repeated ReconnectGridPropInfo gridPropInfos = 7;
  repeated ReconnectSelfTeamMemberInfo selfTeamMemberInfo = 8;
  ReconnectSelfPlayerInfo selfPlayerInfo = 9;
  repeated ReconnectFieldInfo fieldInfos = 10;
  repeated MsgBattleHistoryInfoNotify selfBattleHistory = 11;
}

message MsgReconnectRsp{
  ReconnectGameContext context = 1;
  repeated ReconnectTeamInfo teamInfos = 2;
  repeated ReconnectPlayerInfo playerInfos = 3;
  repeated ReconnectPawnInfo pawnInfos = 4;
  repeated ReconnectCastleInfo castleInfos = 5;
  repeated ReconnectSquadInfo squadInfos = 6;
  repeated ReconnectGridPropInfo gridPropInfos = 7;
  repeated ReconnectSelfTeamMemberInfo selfTeamMemberInfo = 8;
  ReconnectSelfPlayerInfo selfPlayerInfo = 9;
  repeated ReconnectFieldInfo fieldInfos = 10;
  repeated MsgBattleHistoryInfoNotify selfBattleHistory = 11;
}

message MsgInvalidNotify{

}

// 投降投票请求
// 投票分为两个部分：1. 发起投票, 2. 投票
// 对于主动点击投降按钮的人而言，他相当于把这两个部分合并到一起了。即：
// 1. 发起投票的人通过发这个消息发起投票（并且isStarter设置为true）
// 2. 投票被发起，其它队友响应后也会通过这个消息执行投票
message MsgSurrenderReq{
  // 是否同意投降
  bool agree = 1;
  // 是否为投票的发起者
  bool isStarter = 2;
  // 通过MsgPlayerCommandNotify同步到的当前指令次数
  int32 commandCount = 3;
}

message MsgSurrenderRsp{
}

message MsgSurrenderNotify{
  uint64 playerEId = 1;
  repeated uint64 agreeList = 2;
  repeated uint64 rejectList = 3;
  int64 surrenderTime = 4;
  bool isSurrendering = 5;
  int32 needSurrenderCount = 6;
}

message MsgSurrenderSuccessNotify{
  ETeam teamId = 1;
  int64 surrenderTime = 2;
}

message MsgPlayerSurrenderNotify{
  int32 restCount = 1;
}

message NormalValueType{
  bool vbool = 1;
  int32 vi32 = 2;
  uint32 vui32 = 3;
  string vs = 4;
  bytes vbytes = 5;
  repeated int32 vri32 = 6;
}

message MsgTestReq{
  NormalValueType val = 1;
}

message MsgTestRsp{
  NormalValueType val = 1;
}

message RewardInfo{
  uint32 rewardType = 1;
  int32 value = 2;
}

message MsgRewardNotify{
  repeated RewardInfo rewards = 1;
  bool isBattle = 2;
}

message LobbyStoreRedDotInfo{
  repeated int32 clickedStoreItems = 1;
}

enum EPlayerBattleResult
{
  BattleResult_None = 0;   //无事发生
  BattleResult_Dead = 1;   //死亡
  BattleResult_Flee = 2;   //逃跑
}

message MsgPlayerBattleInfo{
  uint64 playerId = 4;
  repeated uint64 killPlayer = 1;
  repeated MsgBattleUnitBattleInfo battleUnits = 2;
  EPlayerBattleResult battleResult = 3;
}

message MsgBattleUnitBattleInfo{
  uint32 pawnId = 1;
  //  uint32 battleUnitId = 2;  //暂时没有意义 召唤物没有图标显示 先注释掉
  uint32 DmgValue = 3;
  uint32 TakeDmgValue = 4;
  uint32 HealValue = 5;
}

message MsgBattleHistoryInfoNotify{
  ETeam winnerTeam = 1;
  int64 startTime = 2;
  uint64 duringTime = 3;

  repeated MsgPlayerBattleInfo playersInfo = 4;
}

// 彩虹卡的的阵容细节(为以后自定义阵容预留 todo)
message MsgCoreCardDeployDetail
{
  // 卡号(包括彩虹卡)列表, 一般5个数(由玩家编辑)
  repeated int32 CardIds = 1;
  // 位置列表, 一般5个数(由玩家编辑)
  repeated int32 Pos = 2;
}

// 彩虹卡的当前选用的阵容
message MsgCoreCardDeploySelected
{
  // 分类:
  // 1: 使用了推荐 RecommendTeam.csv 中的推荐阵容. (1) DeployId 中会填写 RecommendTeam.csv 中的 id
  // 2: 使用了自定义阵容. (1) DeployId 中会填写自定义阵容的 id. (2) DeployDetail 中会填写自定义阵容的细节 (为以后自定义阵容预留 todo)
  int32 Type = 1;

  int32 DeployId = 2;

  // 阵容细节
  MsgCoreCardDeployDetail DeployDetail = 3;
}

// 排位赛信息
message PlayerRankInfo
{
	// 段位
	int32 RankId = 1;
	// 星数
	int32 Star = 2;
}

message SeatPlayer{
  string name = 1;
  string id = 2;
  string ip = 3;
  int64 teamId = 4;
  string token = 5;
  int32 selectedLord = 6;
  int32 selectedSkin = 7;
  int32 initialCoreCardIndex = 8;
  uint32 kcpConv = 9;
  string voiceChatId = 10;
  int32 botId = 11;
  int32 botTypeId = 12;
  uint32 selectSkill = 13;
  MsgCoreCardDeploySelected coreCardDeploySelected = 14;
  int32 MMRScore = 15;
  PlayerRankInfo RankInfo = 16; // 排位赛信息，只有排位赛设置该字段
}

enum LoadingType{
  LTNone = 0;
  LTTeleport = 1;
  LTLordSkill = 2;
  LTAmbush = 3;
  LTGrowRadish = 4;
  LTCollectRadish = 5;
  LTFlyCannon = 6;
  LTBackHome = 7;
}

message LoadingInfo{
  uint64 entityId = 1;
  LoadingType loadingType = 2;
  int64 startLoadingTime = 3;
  int64 endLoadingTime = 4;
}

message MsgLoadingNotify{
  repeated LoadingInfo loadingInfos = 1;
}

message MsgAnimNotify{
  uint64 entityId = 1;
  string animName = 2;
}

message MsgSelectLordFormationReq{
  repeated LordPawnInfo lordFormation = 1;
  int32 commandCount = 2;
}

message MsgSelectLordFormationRsp{
}

enum PlayerVisState {
  PVS_Shopping = 0;
  PVS_Flee = 1;
  PVS_DisConnect = 2;
  PVS_Fighting = 3;
}

message MsgPlayerVisStateReq{
  PlayerVisState state = 1;
  bool stateValue = 2;
}

message MsgPlayerVisStateRsp{
}

message PlayerVisInfo{
  uint64 entityId = 1;
  uint64 state = 2;
}

message MsgPlayerVisStateNotify{
  repeated PlayerVisInfo infos = 1;
}

message MsgBattleSkillNotify{
  uint64 entityId = 1;
  uint32 overrideActiveSkillId = 2;
}

// 刷怪器信息
message SpawnerInfo{
  // 刷怪器的实体id
  uint64 entityId = 1;
  // 刷怪器对应的tid（对应CSVSpawner.Id）
  uint32 dataId = 2;
  // 复活时刻（刷怪器可能会间隔一段时间后刷出指定的单位）
  int64 revivalTick = 3;
  // 要刷出目标单位的地格下标
  int32 targetGridIndex = 4;
  // 要刷出的目标单位tid（依据刷怪器的类型分别对应 CSVGridProp.Id 或 CSVSquad.Id）
  uint32 targetDataId = 5; 
}

// 刷怪器信息通知
message MsgSpawnerSyncNotify{
  // 收到的所有刷怪器信息
  repeated SpawnerInfo infos = 1;
}

message MsgCardLevelUpNotify{
  uint32 originId = 1;
  uint32 targetId = 2;
}

message MsgSkillPrepareReq{
  int32 skillIndex = 1;
  uint32 dataId = 2;
  bool isPrepare = 3;
  int32 targetGridIdx = 4;  // -1 means not select grid
  int32 commandCount = 5;
}

message MsgSkillPrepareRsp{
}

message MsgSkillPrepareNotify{
  uint64 entityId = 1;
  int32 skillIndex = 2;
  uint32 dataId = 3;
  bool isPrepare = 4;
  int32 targetGridIdx = 5;  // -1 means not select grid
  int32 phase = 6;
}
